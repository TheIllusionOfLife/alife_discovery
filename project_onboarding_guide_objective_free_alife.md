# プロジェクト参加者向けオンボーディングガイド
## 目的関数を持たない進化的探索による構造創発

---

## 0. このドキュメントの目的
このドキュメントは、これからプロジェクトに参加する新メンバーが

- 研究の背景
- 何を作ろうとしているのか
- なぜそれが重要なのか
- 具体的に何を実装すればよいのか

を理解し、**すぐに手を動かせる状態になること**を目的とする。

---

## 1. 研究の核心となる問い

本研究の中心にある問いは、非常にシンプルである。

> 目的関数を一切与えず、
> 「壊れていないものだけを残す」選択圧のもとで、
> 意味のある構造は自然に現れるのか？

通常のAIや最適化では：

- スコア
- 報酬
- 評価関数

が存在し、それを最大化する方向に探索が進む。

しかし、この方法には大きな問題がある。

### 評価関数問題
評価関数が間違っていると：

- 本当に正しい解が棄却される
- 革新的なアイデアが消される
- LLMや人間のバイアスが入り込む

例：
- 天動説を信じる評価者は地動説を棄却する

そこで本研究では、次の思想を採用する。

> 「良いものを選ぶ」のではなく、
> 「明らかに壊れているものだけ捨てる」

---

## 2. 本研究の基本戦略（0–1–2–3フロー）

本研究は以下の4ステップで進む。

### Step 0：問題設定
- 世界のルールを決める
- 目的は与えない

### Step 1：大量生成
- ルールや構造をランダムに大量生成
- 意味不明でもOK

### Step 2：破綻排除（最重要）
- 壊れているものだけを落とす
- 面白さや有用性は見ない

### Step 3：観測
- 生き残った系を観察する
- 後から意味を解釈する

この流れを一言で言うと：

> 大量に作って、壊れているものだけ捨てて、
> 残ったものを観察する。

---

## 3. なぜこの研究が重要か

既存のAIやALifeは大きく3種類に分かれる。

### ① 自己組織化系
例：
- セルオートマトン
- Boids

特徴：
- 目的なし
- 選択圧なし

問題：
- 面白い現象が出ても偶然で終わる

### ② 古典的進化的ALife
例：
- Tierra
- Avida

特徴：
- 繁殖成功が目的

問題：
- 暗黙の目的関数がある

### ③ 強化学習型ALife
例：
- マルチエージェントRL

特徴：
- 明確な報酬

問題：
- 完全に目的依存

---

### 本研究の立ち位置

本研究は次の領域に位置する。

> 目的なし × 選択圧あり

具体的には：

- 目的関数：なし
- 報酬：なし
- 適応度：なし
- 選択圧：破綻しないことのみ

これは既存研究ではほとんど扱われていない領域である。

---

## 4. 最小世界モデル（今回実装するもの）

### 世界ルール（10行）

1. 世界は20×20の2Dグリッド（トーラス）。
2. エージェントは30体。
3. 各エージェントは内部状態0〜3を持つ。
4. 観測は自身＋上下左右の近傍状態。
5. 行動は：移動・状態変更・何もしない。
6. 行動はif-thenテーブルで決定。
7. 全エージェントは同一ルールを共有。
8. 衝突や消滅は起きない。
9. シミュレーションは200ステップ。
10. 最後まで破綻しなければ生存。

---

## 5. Step2：破綻判定（停滞も破綻）

本研究では、以下を破綻とみなす。

### 弱フィルタ
- 全停止
- 状態の単一化
- 位置の単一化

### 中フィルタ
- 短周期ループ
- 低活動（停滞）

### 強フィルタ
- 初期条件を変えるとすぐ壊れる（再現性なし）

---

## 6. 「意味のある構造」の定量指標

生存した系に対して、以下を測定する。

### 非自明さ
- 状態エントロピー
- 圧縮率
- 予測可能性

### 空間構造
- 空間自己相関
- クラスタ構造

### 時間構造
- 準周期性
- 相転移

### 役割分化
- 個体行動の偏り

### 情報伝播
- 近傍相互情報量

※これらは**選別には使わない**。
観測・分析専用である。

---

## 7. 実装するソフトウェア構成

### ファイル構成

- world.py：世界とエージェント
- rules.py：ルール生成
- metrics.py：指標計算
- filters.py：破綻判定
- run_search.py：探索本体

---

## 8. 最初の実装タスク（新人向け）

### タスク1：世界を回す
実装するもの：

- エージェント
- トーラス移動
- 観測関数
- 行動更新

完成条件：
- 200ステップ動く

---

### タスク2：ログを取る
各ステップで記録：

- move_count
- state_div
- pos_div
- hash

---

### タスク3：弱フィルタ

以下を実装：

- 完全停止検出
- 状態単一化検出
- 位置単一化検出

---

### タスク4：大量生成ループ

- ランダムルール生成
- シミュレーション実行
- 弱フィルタ適用
- 生存ルール保存

---

## 9. PoCの目標

最初の実験では：

- 10,000ルール生成
- 弱・中・強フィルタ適用
- 生存数を比較

出力例：

| フィルタ段階 | 生存数 |
|-------------|--------|
| Weakのみ | 1,200 |
| Weak+Medium | 230 |
| Weak+Medium+Strong | 41 |

---

## 10. 成功と失敗の意味

### 成功
- 役割分化
- 空間構造
- 長期的ダイナミクス

が観測される。

### 失敗
- 停滞
- ノイズ
- 短周期ループ

のみが残る。

どちらでも研究として意味がある。

---

## 11. この研究の一言要約

> 良いものを選ぶのではなく、
> 壊れているものだけを捨てたら、
> 意味のある構造は自然に生まれるのかを調べる研究。

---

## 12. 新人が最初にやること（チェックリスト）

- [ ] world.py を実装
- [ ] 200ステップ回ることを確認
- [ ] metrics.py を実装
- [ ] 弱フィルタを実装
- [ ] 1,000ルール探索を実行
- [ ] 生存数を出力

ここまでできれば、研究の土台は完成。

